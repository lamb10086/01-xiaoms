{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\nvar _definitions = require(\"../definitions\");\nvar _generated = require(\"../validators/generated\");\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\nfunction cloneIfNode(obj, deep, withoutLoc, commentsCache) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n  return obj;\n}\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\nfunction cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n  if ((0, _generated.isIdentifier)(node)) {\n    newNode.name = node.name;\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _generated.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);\n  }\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);\n  }\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);\n  }\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n  return newNode;\n}\nfunction maybeCloneComments(comments, deep, withoutLoc, commentsCache) {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n    const {\n      type,\n      value,\n      loc\n    } = comment;\n    const ret = {\n      type,\n      value,\n      loc\n    };\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n    commentsCache.set(comment, ret);\n    return ret;\n  });\n}","map":{"version":3,"mappings":"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","names":["has","Function","call","bind","Object","prototype","hasOwnProperty","cloneIfNode","obj","deep","withoutLoc","commentsCache","type","cloneNodeInternal","cloneIfNodeOrArray","Array","isArray","map","node","cloneNode","Map","newNode","name","optional","typeAnnotation","NODE_FIELDS","Error","field","keys","maybeCloneComments","comments","loc","leadingComments","innerComments","trailingComments","extra","comment","cache","get","value","ret","set"],"sources":["../../src/clone/cloneNode.ts"],"sourcesContent":["import { NODE_FIELDS } from \"../definitions\";\nimport type * as t from \"..\";\nimport { isFile, isIdentifier } from \"../validators/generated\";\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\ntype CommentCache = Map<t.Comment, t.Comment>;\n\n// This function will never be called for comments, only for real nodes.\nfunction cloneIfNode(\n  obj: t.Node | undefined | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(\n  obj: t.Node | undefined | null | (t.Node | undefined | null)[],\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\n\n/**\n * Create a clone of a `node` including only properties belonging to the node.\n * If the second parameter is `false`, cloneNode performs a shallow clone.\n * If the third parameter is true, the cloned nodes exclude location properties.\n */\nexport default function cloneNode<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n): T {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\n\nfunction cloneNodeInternal<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n  commentsCache: CommentCache,\n): T {\n  if (!node) return node;\n\n  const { type } = node;\n  const newNode: any = { type: node.type };\n\n  // Special-case identifiers since they are the most cloned nodes.\n  if (isIdentifier(node)) {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep\n        ? cloneIfNodeOrArray(\n            node.typeAnnotation,\n            true,\n            withoutLoc,\n            commentsCache,\n          )\n        : node.typeAnnotation;\n    }\n  } else if (!has(NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] =\n            isFile(node) && field === \"comments\"\n              ? maybeCloneComments(\n                  node.comments,\n                  deep,\n                  withoutLoc,\n                  commentsCache,\n                )\n              : cloneIfNodeOrArray(\n                  // @ts-expect-error node[field] has been guarded by has check\n                  node[field],\n                  true,\n                  withoutLoc,\n                  commentsCache,\n                );\n        } else {\n          newNode[field] =\n            // @ts-expect-error node[field] has been guarded by has check\n            node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(\n      node.leadingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(\n      node.innerComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(\n      node.trailingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (has(node, \"extra\")) {\n    newNode.extra = {\n      ...node.extra,\n    };\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments<T extends t.Comment>(\n  comments: ReadonlyArray<T> | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: Map<T, T>,\n): ReadonlyArray<T> | null {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n\n    const { type, value, loc } = comment;\n\n    const ret = { type, value, loc } as T;\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n\n    commentsCache.set(comment, ret);\n\n    return ret;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}