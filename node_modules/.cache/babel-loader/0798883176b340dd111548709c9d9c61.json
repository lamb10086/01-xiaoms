{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = gatherSequenceExpressions;\nvar _getBindingIdentifiers = require(\"../retrievers/getBindingIdentifiers\");\nvar _generated = require(\"../validators/generated\");\nvar _generated2 = require(\"../builders/generated\");\nvar _cloneNode = require(\"../clone/cloneNode\");\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n  for (const node of nodes) {\n    if (!(0, _generated.isEmptyStatement)(node)) {\n      ensureLastUndefined = false;\n    }\n    if ((0, _generated.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _generated.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _generated.isVariableDeclaration)(node)) {\n      if (node.kind !== \"var\") return;\n      for (const declar of node.declarations) {\n        const bindings = (0, _getBindingIdentifiers.default)(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n        if (declar.init) {\n          exprs.push((0, _generated2.assignmentExpression)(\"=\", declar.id, declar.init));\n        }\n      }\n      ensureLastUndefined = true;\n    } else if ((0, _generated.isIfStatement)(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _generated.isBlockStatement)(node)) {\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _generated.isEmptyStatement)(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _generated2.sequenceExpression)(exprs);\n  }\n}","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AAQA;AAKA;AASe,SAASA,yBAAT,CACbC,KADa,EAEbC,KAFa,EAGbC,OAHa,EAIb;EACA,MAAMC,KAAqB,GAAG,EAA9B;EACA,IAAIC,mBAAmB,GAAG,IAA1B;EAEA,KAAK,MAAMC,IAAX,IAAmBL,KAAnB,EAA0B;IAGxB,IAAI,CAAC,iCAAiBK,IAAjB,CAAL,EAA6B;MAC3BD,mBAAmB,GAAG,KAAtB;IACD;IAED,IAAI,6BAAaC,IAAb,CAAJ,EAAwB;MACtBF,KAAK,CAACG,IAAN,CAAWD,IAAX;IACD,CAFD,MAEO,IAAI,sCAAsBA,IAAtB,CAAJ,EAAiC;MACtCF,KAAK,CAACG,IAAN,CAAWD,IAAI,CAACE,UAAhB;IACD,CAFM,MAEA,IAAI,sCAAsBF,IAAtB,CAAJ,EAAiC;MACtC,IAAIA,IAAI,CAACG,IAAL,KAAc,KAAlB,EAAyB;MAEzB,KAAK,MAAMC,MAAX,IAAqBJ,IAAI,CAACK,YAA1B,EAAwC;QACtC,MAAMC,QAAQ,GAAG,oCAAsBF,MAAtB,CAAjB;QACA,KAAK,MAAMG,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYH,QAAZ,CAAlB,EAAyC;UACvCT,OAAO,CAACI,IAAR,CAAa;YACXE,IAAI,EAAEH,IAAI,CAACG,IADA;YAEXO,EAAE,EAAE,wBAAUJ,QAAQ,CAACC,GAAD,CAAlB;UAFO,CAAb;QAID;QAED,IAAIH,MAAM,CAACO,IAAX,EAAiB;UACfb,KAAK,CAACG,IAAN,CAAW,sCAAqB,GAArB,EAA0BG,MAAM,CAACM,EAAjC,EAAqCN,MAAM,CAACO,IAA5C,CAAX;QACD;MACF;MAEDZ,mBAAmB,GAAG,IAAtB;IACD,CAlBM,MAkBA,IAAI,8BAAcC,IAAd,CAAJ,EAAyB;MAC9B,MAAMY,UAAU,GAAGZ,IAAI,CAACY,UAAL,GACflB,yBAAyB,CAAC,CAACM,IAAI,CAACY,UAAN,CAAD,EAAoBhB,KAApB,EAA2BC,OAA3B,CADV,GAEfD,KAAK,CAACiB,kBAAN,EAFJ;MAGA,MAAMC,SAAS,GAAGd,IAAI,CAACc,SAAL,GACdpB,yBAAyB,CAAC,CAACM,IAAI,CAACc,SAAN,CAAD,EAAmBlB,KAAnB,EAA0BC,OAA1B,CADX,GAEdD,KAAK,CAACiB,kBAAN,EAFJ;MAGA,IAAI,CAACD,UAAD,IAAe,CAACE,SAApB,EAA+B;MAE/BhB,KAAK,CAACG,IAAN,CAAW,uCAAsBD,IAAI,CAACe,IAA3B,EAAiCH,UAAjC,EAA6CE,SAA7C,CAAX;IACD,CAVM,MAUA,IAAI,iCAAiBd,IAAjB,CAAJ,EAA4B;MACjC,MAAMgB,IAAI,GAAGtB,yBAAyB,CAACM,IAAI,CAACgB,IAAN,EAAYpB,KAAZ,EAAmBC,OAAnB,CAAtC;MACA,IAAI,CAACmB,IAAL,EAAW;MAEXlB,KAAK,CAACG,IAAN,CAAWe,IAAX;IACD,CALM,MAKA,IAAI,iCAAiBhB,IAAjB,CAAJ,EAA4B;MAGjC,IAAIL,KAAK,CAACsB,OAAN,CAAcjB,IAAd,MAAwB,CAA5B,EAA+B;QAC7BD,mBAAmB,GAAG,IAAtB;MACD;IACF,CANM,MAMA;MAEL;IACD;EACF;EAED,IAAIA,mBAAJ,EAAyB;IACvBD,KAAK,CAACG,IAAN,CAAWL,KAAK,CAACiB,kBAAN,EAAX;EACD;EAED,IAAIf,KAAK,CAACoB,MAAN,KAAiB,CAArB,EAAwB;IACtB,OAAOpB,KAAK,CAAC,CAAD,CAAZ;EACD,CAFD,MAEO;IACL,OAAO,oCAAmBA,KAAnB,CAAP;EACD;AACF","names":["gatherSequenceExpressions","nodes","scope","declars","exprs","ensureLastUndefined","node","push","expression","kind","declar","declarations","bindings","key","Object","keys","id","init","consequent","buildUndefinedNode","alternate","test","body","indexOf","length"],"sources":["../../src/converters/gatherSequenceExpressions.ts"],"sourcesContent":["import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers\";\nimport {\n  isExpression,\n  isExpressionStatement,\n  isVariableDeclaration,\n  isIfStatement,\n  isBlockStatement,\n  isEmptyStatement,\n} from \"../validators/generated\";\nimport {\n  sequenceExpression,\n  assignmentExpression,\n  conditionalExpression,\n} from \"../builders/generated\";\nimport cloneNode from \"../clone/cloneNode\";\nimport type * as t from \"..\";\nimport type { Scope } from \"@babel/traverse\";\n\nexport type DeclarationInfo = {\n  kind: t.VariableDeclaration[\"kind\"];\n  id: t.Identifier;\n};\n\nexport default function gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  scope: Scope,\n  declars: Array<DeclarationInfo>,\n) {\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: cloneNode(bindings[key]),\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], scope, declars)\n        : scope.buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], scope, declars)\n        : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      // bailed, we can't turn this statement into an expression\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}