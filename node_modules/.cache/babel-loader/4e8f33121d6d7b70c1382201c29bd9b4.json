{"ast":null,"code":"\"use strict\";\n\nvar _utils = require(\"./utils\");\nvar _core = require(\"./core\");\nvar _is = require(\"../validators/is\");\nconst defineType = (0, _utils.defineAliasedType)(\"TypeScript\");\nconst bool = (0, _utils.assertValueType)(\"boolean\");\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n    },\n    override: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  }\n});\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: (0, _utils.validateType)(\"TSEntityName\"),\n    right: (0, _utils.validateType)(\"Identifier\")\n  }\n});\nconst signatureDeclarationCommon = () => ({\n  typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n  [\"parameters\"]: (0, _utils.validateArrayOfType)([\"Identifier\", \"RestElement\"]),\n  [\"typeAnnotation\"]: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n});\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon()\n};\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\nconst namedTypeElementCommon = () => ({\n  key: (0, _utils.validateType)(\"Expression\"),\n  computed: {\n    default: false\n  },\n  optional: (0, _utils.validateOptional)(bool)\n});\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\", \"initializer\"],\n  fields: Object.assign({}, namedTypeElementCommon(), {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\"),\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    static: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n  }\n});\nconst tsKeywordTypes = [\"TSAnyKeyword\", \"TSBooleanKeyword\", \"TSBigIntKeyword\", \"TSIntrinsicKeyword\", \"TSNeverKeyword\", \"TSNullKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\", \"TSVoidKeyword\"];\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {}\n  });\n}\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {}\n});\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"]\n};\ndefineType(\"TSFunctionType\", Object.assign({}, fnOrCtrBase, {\n  fields: signatureDeclarationCommon()\n}));\ndefineType(\"TSConstructorType\", Object.assign({}, fnOrCtrBase, {\n  fields: Object.assign({}, signatureDeclarationCommon(), {\n    abstract: (0, _utils.validateOptional)(bool)\n  })\n}));\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: (0, _utils.validateType)([\"Identifier\", \"TSThisType\"]),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: (0, _utils.validateType)([\"TSEntityName\", \"TSImportType\"]),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)([\"TSType\", \"TSNamedTupleMember\"])\n  }\n});\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: (0, _utils.validateType)(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n};\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: (0, _utils.validateType)(\"TSType\"),\n    extendsType: (0, _utils.validateType)(\"TSType\"),\n    trueType: (0, _utils.validateType)(\"TSType\"),\n    falseType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }\n});\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"TSType\"),\n    indexType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\"),\n    nameType: (0, _utils.validateOptionalType)(\"TSType\")\n  }\n});\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: function () {\n        const unaryExpression = (0, _utils.assertNodeType)(\"NumericLiteral\", \"BigIntLiteral\");\n        const unaryOperator = (0, _utils.assertOneOf)(\"-\");\n        const literal = (0, _utils.assertNodeType)(\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\");\n        function validator(parent, key, node) {\n          if ((0, _is.default)(\"UnaryExpression\", node)) {\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            literal(parent, key, node);\n          }\n        }\n        validator.oneOfNodeTypes = [\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\", \"UnaryExpression\"];\n        return validator;\n      }()\n    }\n  }\n});\ndefineType(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSInterfaceDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n    body: (0, _utils.validateType)(\"TSInterfaceBody\")\n  }\n});\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSAsExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSEnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    global: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    body: (0, _utils.validateType)([\"TSModuleBlock\", \"TSModuleDeclaration\"])\n  }\n});\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"argument\", \"qualifier\", \"typeParameters\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"StringLiteral\"),\n    qualifier: (0, _utils.validateOptionalType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: (0, _utils.validate)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    moduleReference: (0, _utils.validateType)([\"TSEntityName\", \"TSExternalModuleReference\"]),\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TSType\")\n    }\n  }\n});\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")))\n    }\n  }\n});\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSTypeParameter\")))\n    }\n  }\n});\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    in: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    out: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    }\n  }\n});","map":{"version":3,"mappings":"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","names":["defineType","bool","tSFunctionTypeAnnotationCommon","returnType","validate","optional","typeParameters","aliases","visitor","fields","accessibility","readonly","parameter","override","decorators","left","right","signatureDeclarationCommon","callConstructSignatureDeclaration","namedTypeElementCommon","key","computed","default","typeAnnotation","initializer","kind","static","parameters","tsKeywordTypes","type","fnOrCtrBase","abstract","typeName","builder","parameterName","asserts","exprName","members","elementType","elementTypes","label","unionOrIntersection","types","checkType","extendsType","trueType","falseType","typeParameter","operator","objectType","indexType","nameType","literal","unaryExpression","unaryOperator","validator","parent","node","argument","oneOfNodeTypes","expression","declare","id","extends","body","const","global","qualifier","isExport","moduleReference","importKind","params","name","in","out","constraint"],"sources":["../../src/definitions/typescript.ts"],"sourcesContent":["import {\n  defineAliasedType,\n  arrayOfType,\n  assertEach,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n  chain,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n} from \"./utils\";\nimport {\n  functionDeclarationCommon,\n  classMethodOrDeclareMethodCommon,\n} from \"./core\";\nimport is from \"../validators/is\";\n\nconst defineType = defineAliasedType(\"TypeScript\");\n\nconst bool = assertValueType(\"boolean\");\n\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeAnnotation\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeParameterDeclaration\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true,\n  },\n});\n\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"], // TODO: This isn't usable in general as an LVal. Should have a \"Parameter\" alias.\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: assertOneOf(\"public\", \"private\", \"protected\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    parameter: {\n      validate: assertNodeType(\"Identifier\", \"AssignmentPattern\"),\n    },\n    override: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: validateType(\"TSEntityName\"),\n    right: validateType(\"Identifier\"),\n  },\n});\n\nconst signatureDeclarationCommon = () => ({\n  typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n  [process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\"]: validateArrayOfType(\n    [\"Identifier\", \"RestElement\"],\n  ),\n  [process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\"]:\n    validateOptionalType(\"TSTypeAnnotation\"),\n});\n\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: signatureDeclarationCommon(),\n};\n\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\n  \"TSConstructSignatureDeclaration\",\n  callConstructSignatureDeclaration,\n);\n\nconst namedTypeElementCommon = () => ({\n  key: validateType(\"Expression\"),\n  computed: { default: false },\n  optional: validateOptional(bool),\n});\n\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\", \"initializer\"],\n  fields: {\n    ...namedTypeElementCommon(),\n    readonly: validateOptional(bool),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    initializer: validateOptionalType(\"Expression\"),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"key\",\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: {\n    ...signatureDeclarationCommon(),\n    ...namedTypeElementCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: validateOptional(bool),\n    static: validateOptional(bool),\n    parameters: validateArrayOfType(\"Identifier\"), // Length must be 1\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n  },\n});\n\nconst tsKeywordTypes = [\n  \"TSAnyKeyword\",\n  \"TSBooleanKeyword\",\n  \"TSBigIntKeyword\",\n  \"TSIntrinsicKeyword\",\n  \"TSNeverKeyword\",\n  \"TSNullKeyword\",\n  \"TSNumberKeyword\",\n  \"TSObjectKeyword\",\n  \"TSStringKeyword\",\n  \"TSSymbolKeyword\",\n  \"TSUndefinedKeyword\",\n  \"TSUnknownKeyword\",\n  \"TSVoidKeyword\",\n] as const;\n\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {},\n  });\n}\n\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {},\n});\n\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n};\n\ndefineType(\"TSFunctionType\", {\n  ...fnOrCtrBase,\n  fields: signatureDeclarationCommon(),\n});\ndefineType(\"TSConstructorType\", {\n  ...fnOrCtrBase,\n  fields: {\n    ...signatureDeclarationCommon(),\n    abstract: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: validateType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: validateType([\"Identifier\", \"TSThisType\"]),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    asserts: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: validateType([\"TSEntityName\", \"TSImportType\"]),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: validateArrayOfType([\"TSType\", \"TSNamedTupleMember\"]),\n  },\n});\n\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: validateType(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false,\n    },\n    elementType: validateType(\"TSType\"),\n  },\n});\n\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: validateArrayOfType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\n\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: validateType(\"TSType\"),\n    extendsType: validateType(\"TSType\"),\n    trueType: validateType(\"TSType\"),\n    falseType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: validateType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: validate(assertValueType(\"string\")),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: validateType(\"TSType\"),\n    indexType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    readonly: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeParameter: validateType(\"TSTypeParameter\"),\n    optional: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeAnnotation: validateOptionalType(\"TSType\"),\n    nameType: validateOptionalType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: (function () {\n        const unaryExpression = assertNodeType(\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const unaryOperator = assertOneOf(\"-\");\n\n        const literal = assertNodeType(\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n        );\n        function validator(parent: any, key: string, node: any) {\n          // type A = -1 | 1;\n          if (is(\"UnaryExpression\", node)) {\n            // check operator first\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            // type A = 'foo' | 'bar' | false | 1;\n            literal(parent, key, node);\n          }\n        }\n\n        validator.oneOfNodeTypes = [\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n          \"UnaryExpression\",\n        ];\n\n        return validator;\n      })(),\n    },\n  },\n});\n\ndefineType(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSInterfaceDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    extends: validateOptional(arrayOfType(\"TSExpressionWithTypeArguments\")),\n    body: validateType(\"TSInterfaceBody\"),\n  },\n});\n\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSAsExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: validateOptional(bool),\n    const: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    members: validateArrayOfType(\"TSEnumMember\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: validateType([\"Identifier\", \"StringLiteral\"]),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    global: validateOptional(bool),\n    id: validateType([\"Identifier\", \"StringLiteral\"]),\n    body: validateType([\"TSModuleBlock\", \"TSModuleDeclaration\"]),\n  },\n});\n\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"argument\", \"qualifier\", \"typeParameters\"],\n  fields: {\n    argument: validateType(\"StringLiteral\"),\n    qualifier: validateOptionalType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: validate(bool),\n    id: validateType(\"Identifier\"),\n    moduleReference: validateType([\n      \"TSEntityName\",\n      \"TSExternalModuleReference\",\n    ]),\n    importKind: {\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: assertNodeType(\"TSType\"),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSType\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSTypeParameter\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: !process.env.BABEL_8_BREAKING\n        ? assertValueType(\"string\")\n        : assertNodeType(\"Identifier\"),\n    },\n    in: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    out: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    constraint: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n    default: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n  },\n});\n"]},"metadata":{},"sourceType":"module"}